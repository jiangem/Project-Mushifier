'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateUploadKeystore = exports.createKeystore = exports.logKeystoreHashes = exports.exportPrivateKey = exports.exportCert = exports.backupExistingCredentials = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

let backupExistingCredentials = exports.backupExistingCredentials = (() => {
  var _ref = _asyncToGenerator(function* ({ outputPath, username, experienceName }, log = (_Logger || _load_Logger()).default.info.bind((_Logger || _load_Logger()).default), logSecrets = true) {
    const credentialMetadata = { username, experienceName, platform: 'android' };

    log(`Retreiving Android keystore for ${experienceName}`);

    const credentials = yield (0, (_Credentials || _load_Credentials()).getCredentialsForPlatform)(credentialMetadata);
    if (!credentials) {
      throw new Error('Unable to fetch credentials for this project. Are you sure they exist?');
    }
    const { keystore, keystorePassword, keystoreAlias: keyAlias, keyPassword } = credentials;

    const storeBuf = Buffer.from(keystore, 'base64');
    log(`Writing keystore to ${outputPath}...`);
    (_fsExtra || _load_fsExtra()).default.writeFileSync(outputPath, storeBuf);
    if (logSecrets) {
      log('Done writing keystore to disk.');
      log(`${(_chalk || _load_chalk()).default.yellow('Save these important values as well:')}

  Keystore password: ${(_chalk || _load_chalk()).default.bold(keystorePassword)}
  Key alias:         ${(_chalk || _load_chalk()).default.bold(keyAlias)}
  Key password:      ${(_chalk || _load_chalk()).default.bold(keyPassword)}
  `);
    }
    return {
      keystorePassword,
      keyAlias,
      keyPassword
    };
  });

  return function backupExistingCredentials(_x) {
    return _ref.apply(this, arguments);
  };
})();

let exportCert = exports.exportCert = (() => {
  var _ref2 = _asyncToGenerator(function* (keystorePath, keystorePassword, keyAlias, certFile) {
    return (0, (_spawnAsync || _load_spawnAsync()).default)('keytool', ['-exportcert', '-keystore', keystorePath, '-storepass', keystorePassword, '-alias', keyAlias, '-file', certFile, '-noprompt', '-storetype', 'JKS']);
  });

  return function exportCert(_x2, _x3, _x4, _x5) {
    return _ref2.apply(this, arguments);
  };
})();

let exportPrivateKey = exports.exportPrivateKey = (() => {
  var _ref3 = _asyncToGenerator(function* ({ keystorePath, keystorePassword, keyAlias, keyPassword }, encryptionKey, outputPath, log = (_Logger || _load_Logger()).default.info.bind((_Logger || _load_Logger()).default)) {
    let nodePty;
    const ptyTmpDir = '/tmp/pty-tmp-install';
    try {
      // it's not very pretty solution, but we decided to use it because it's affecting only people using
      // this command and if node-pty is supported on that system instalation process will be invisble for user.
      nodePty = require('node-pty-prebuilt');
    } catch (err) {
      try {
        log('Installing node-pty-prebuilt in temporary directory');
        yield (_fsExtra || _load_fsExtra()).default.mkdirp(ptyTmpDir);
        yield (0, (_spawnAsync || _load_spawnAsync()).default)('npm', ['init', '--yes'], { cwd: ptyTmpDir });
        yield (0, (_spawnAsync || _load_spawnAsync()).default)('npm', ['install', 'node-pty-prebuilt'], {
          cwd: ptyTmpDir,
          stdio: ['pipe', 1, 2]
        });
        nodePty = require(`${ptyTmpDir}/node_modules/node-pty-prebuilt`);
      } catch (err) {
        log(`Run ${(_chalk || _load_chalk()).default.cyan('npm -g install node-pty-prebuilt')} to install node pty`);
        throw new Error('Package node-pty-prebuilt is required to use PEPK tool');
      }
    }
    const ptySpawn = nodePty.spawn;
    const encryptToolPath = _path.default.join((_UserSettings || _load_UserSettings()).default.dotExpoHomeDirectory(), 'android_tools_pepk.jar');
    if (!(_fsExtra || _load_fsExtra()).default.existsSync(encryptToolPath)) {
      log(`Downloading PEPK tool from Google Play to ${encryptToolPath}`);
      const downloadUrl = 'https://www.gstatic.com/play-apps-publisher-rapid/signing-tool/prod/pepk.jar';
      const file = (_fsExtra || _load_fsExtra()).default.createWriteStream(encryptToolPath);
      const response = yield (0, (_axios || _load_axios()).default)({ url: downloadUrl, method: 'GET', responseType: 'stream' });
      const bar = new (_progress || _load_progress()).default('  downloading pepk tool [:bar] :rate/bps :percent :etas', {
        complete: '=',
        incomplete: ' ',
        width: 40,
        total: parseInt(response.headers['content-length'], 10)
      });
      response.data.pipe(file);
      response.data.on('data', function (chunk) {
        return bar.tick(chunk.length);
      });
      yield new Promise(function (resolve, reject) {
        file.on('finish', resolve);
        file.on('error', reject);
      });
    }
    try {
      yield new Promise(function (res, rej) {
        const child = ptySpawn(javaExecutable, ['-jar', encryptToolPath, '--keystore', keystorePath, '--alias', keyAlias, '--output', outputPath, '--encryptionkey', encryptionKey], {
          name: 'pepk tool',
          cols: 80,
          rows: 30,
          cwd: process.cwd(),
          env: process.env
        });
        child.on('error', function (err) {
          log('error', err);
          rej(err);
        });
        child.on('exit', function (exitCode) {
          if (exitCode != 0) {
            rej(exitCode);
          } else {
            res();
          }
        });
        child.write(keystorePassword + NEWLINE);
        child.write(keyPassword + NEWLINE);
      });
      log(`Exported and encrypted private app signing key to file ${outputPath}`);
    } catch (error) {
      throw new Error(`PEPK tool failed with return code ${error}`);
    } finally {
      (_fsExtra || _load_fsExtra()).default.remove(ptyTmpDir);
    }
  });

  return function exportPrivateKey(_x6, _x7, _x8) {
    return _ref3.apply(this, arguments);
  };
})();

let logKeystoreHashes = exports.logKeystoreHashes = (() => {
  var _ref4 = _asyncToGenerator(function* ({ keystorePath, keystorePassword, keyAlias }, log = (_Logger || _load_Logger()).default.info.bind((_Logger || _load_Logger()).default)) {
    const certFile = `${keystorePath}.cer`;
    try {
      yield exportCert(keystorePath, keystorePassword, keyAlias, certFile);
      const data = (_fsExtra || _load_fsExtra()).default.readFileSync(certFile);
      const googleHash = _crypto.default.createHash('sha1').update(data).digest('hex').toUpperCase();
      const googleHash256 = _crypto.default.createHash('sha256').update(data).digest('hex').toUpperCase();
      const fbHash = _crypto.default.createHash('sha1').update(data).digest('base64');
      log(`Google Certificate Fingerprint:     ${googleHash.replace(/(.{2}(?!$))/g, '$1:')}`);
      log(`Google Certificate Hash (SHA-1):    ${googleHash}`);
      log(`Google Certificate Hash (SHA-256):  ${googleHash256}`);
      log(`Facebook Key Hash:                  ${fbHash}`);
    } catch (err) {
      if (err.code === 'ENOENT') {
        log.warn('Are you sure you have keytool installed?');
        log('keytool is part of OpenJDK: https://openjdk.java.net/');
        log('Also make sure that keytool is in your PATH after installation.');
      }
      if (err.stdout) {
        log(err.stdout);
      }
      if (err.stderr) {
        log.error(err.stderr);
      }
      throw err;
    } finally {
      try {
        (_fsExtra || _load_fsExtra()).default.unlinkSync(certFile);
      } catch (err) {
        if (err.code !== 'ENOENT') {
          log.error(err);
        }
      }
    }
  });

  return function logKeystoreHashes(_x9) {
    return _ref4.apply(this, arguments);
  };
})();

let createKeystore = exports.createKeystore = (() => {
  var _ref5 = _asyncToGenerator(function* ({ keystorePath, keystorePassword, keyAlias, keyPassword }, androidPackage) {
    return (0, (_spawnAsync || _load_spawnAsync()).default)('keytool', ['-genkey', '-v', '-storepass', keystorePassword, '-keypass', keyPassword, '-keystore', keystorePath, '-alias', keyAlias, '-keyalg', 'RSA', '-keysize', '2048', '-validity', '10000', '-dname', `CN=${androidPackage},OU=,O=,L=,S=,C=US`]);
  });

  return function createKeystore(_x10, _x11) {
    return _ref5.apply(this, arguments);
  };
})();

let generateUploadKeystore = exports.generateUploadKeystore = (() => {
  var _ref6 = _asyncToGenerator(function* (uploadKeystorePath, androidPackage, experienceName) {
    const keystoreData = {
      keystorePassword: (0, (_v || _load_v()).default)().replace(/-/g, ''),
      keyPassword: (0, (_v || _load_v()).default)().replace(/-/g, ''),
      keyAlias: Buffer.from(experienceName).toString('base64')
    };
    yield createKeystore(_extends({ keystorePath: uploadKeystorePath }, keystoreData), androidPackage);
    return keystoreData;
  });

  return function generateUploadKeystore(_x12, _x13, _x14) {
    return _ref6.apply(this, arguments);
  };
})();

exports.logKeystoreCredentials = logKeystoreCredentials;

var _path = _interopRequireDefault(require('path'));

var _fsExtra;

function _load_fsExtra() {
  return _fsExtra = _interopRequireDefault(require('fs-extra'));
}

var _chalk;

function _load_chalk() {
  return _chalk = _interopRequireDefault(require('chalk'));
}

var _crypto = _interopRequireDefault(require('crypto'));

var _v;

function _load_v() {
  return _v = _interopRequireDefault(require('uuid/v4'));
}

var _spawnAsync;

function _load_spawnAsync() {
  return _spawnAsync = _interopRequireDefault(require('@expo/spawn-async'));
}

var _axios;

function _load_axios() {
  return _axios = _interopRequireDefault(require('axios'));
}

var _progress;

function _load_progress() {
  return _progress = _interopRequireDefault(require('progress'));
}

var _Credentials;

function _load_Credentials() {
  return _Credentials = require('./Credentials');
}

var _Logger;

function _load_Logger() {
  return _Logger = _interopRequireDefault(require('../Logger'));
}

var _UserSettings;

function _load_UserSettings() {
  return _UserSettings = _interopRequireDefault(require('../UserSettings'));
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const NEWLINE = process.platform === 'win32' ? '\r\n' : '\n';
const javaExecutable = process.platform === 'win32' ? 'java.exe' : 'java';

function logKeystoreCredentials({ keystorePassword, keyAlias, keyPassword }, title = 'Keystore credentials', log = (_Logger || _load_Logger()).default.info.bind((_Logger || _load_Logger()).default)) {
  log(`${title}
    Keystore password: ${(_chalk || _load_chalk()).default.bold(keystorePassword)}
    Key alias:         ${(_chalk || _load_chalk()).default.bold(keyAlias)}
    Key password:      ${(_chalk || _load_chalk()).default.bold(keyPassword)}
  `);
}
//# sourceMappingURL=../__sourcemaps__/credentials/AndroidCredentials.js.map
